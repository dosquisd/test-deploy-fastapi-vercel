from typing import Annotated

from fastapi import FastAPI, Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
from sqlalchemy.orm import Session

import schemas
from schemas import Token, TokenData
from database import SessionLocal

import jwt
import uvicorn
from jwt.exceptions import InvalidTokenError

from crud_users import authenticate_user, get_user, create_user, \
    update_user, delete_user

from os import getenv
from dotenv import load_dotenv

load_dotenv()

app = FastAPI()

oauth2_scheme = OAuth2PasswordBearer("/token")

SECRET_KEY, ALGORITHM = getenv("SECRET_KEY"), getenv("ALGORITHM")


def get_db():
    """
    Provides a database session for a request, ensuring that the session is 
    properly closed after use.

    Yields:
        Session: A database session to be used within a request context.
    """
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()


def create_access_token(data: dict) -> str:
    """
    Creates a JWT access token by encoding the provided data.

    Args:
        data (dict): The data to be encoded in the JWT token.

    Returns:
        str: The encoded JWT token as a string.
    """
    to_encode = data.copy()
    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt


async def get_current_user(token: Annotated[str, Depends(oauth2_scheme)], db: Session = Depends(get_db)) -> schemas.User:
    """
    Retrieves the current user based on the provided JWT token.

    Args:
        token (Annotated[str, Depends]): The JWT token provided by the user.
        db (Session, optional): The database session used to query the database.
            Defaults to a session generated by `get_db`.

    Returns:
        schemas.User: The user object retrieved from the database.

    Raises:
        HTTPException: If the token is invalid, expired, or if the user is not found.
    """
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="No se pudieron validar las credenciales",
        headers={"WWW-Authenticate": "Bearer"}
    )

    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        username = payload.get("sub")
        if username is None:
            raise credentials_exception
        token_data = TokenData(username=username)
    except InvalidTokenError:
        raise credentials_exception
    
    user = get_user(db, token_data.username)
    if user is None:
        raise credentials_exception
    return schemas.User(dni=user.dni, username=user.username, kind=user.kind, password=user.password)


@app.get("/")
async def root() -> str:
    """
    A simple root endpoint that returns a basic string response.

    Returns:
        str: A string indicating the root of the API.
    """
    return "root"


@app.post("/token")
async def login(form_data: Annotated[OAuth2PasswordRequestForm, Depends()], db: Session = Depends(get_db)) -> Token:
    """
    Authenticates a user and returns a JWT token upon successful login.

    Args:
        form_data (Annotated[OAuth2PasswordRequestForm, Depends]): The form data
            containing the username and password for authentication.
        db (Session, optional): The database session used to query the database.
            Defaults to a session generated by `get_db`.

    Returns:
        Token: An object containing the access token and its type.

    Raises:
        HTTPException: If the username or password is incorrect.
    """
    user = authenticate_user(db, form_data.username, form_data.password)
    if user is None:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail='Nombre de usuario o contraseÃ±a incorrecto',
            headers={"WWW-Authenticate": "Bearer"}
        )
    access_token = create_access_token({"sub": user.username})

    return Token(access_token=access_token, token_type="bearer")


@app.get("/users/me", response_model=schemas.User)
async def read_user_me(current_user: Annotated[schemas.User, Depends(get_current_user)]) -> schemas.User:
    """
    Retrieves the current authenticated user's information.

    Args:
        current_user (Annotated[schemas.User, Depends]): The current user 
            obtained from the JWT token.

    Returns:
        schemas.User: The information of the current authenticated user.
    """
    return current_user


@app.get("/users/{username}", response_model=schemas.User)
def get(username: str, current_user: Annotated[schemas.User, Depends(get_current_user)],
        db: Session = Depends(get_db)) -> schemas.User:
    """
    Retrieves the details of a specific user by username if the current user is an admin.

    Args:
        username (str): The username of the user to retrieve.
        current_user (Annotated[schemas.User, Depends]): The currently authenticated user,
            obtained from the JWT token, who is attempting to retrieve the user details.
        db (Session, optional): The database session used to query the database.
            Defaults to a session generated by `get_db`.

    Returns:
        schemas.User: The user details corresponding to the provided username.

    Raises:
        HTTPException: If the current user is not an admin or if the user is not found.
    """
    if current_user.kind != 'admin':
        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED,
                             detail='You are not an admin user')

    user_db = get_user(db, username)
    if user_db is None:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND,
                            detail='User not found')

    return schemas.User(dni=user_db.dni, username=user_db.username, kind=user_db.kind, password=user_db.password)


@app.post("/users/", response_model=schemas.User)
def create(user: schemas.User, current_user: Annotated[schemas.User, Depends(get_current_user)],
             db: Session = Depends(get_db)) -> schemas.User:
    """
    Creates a new user if the current user is an admin.

    Args:
        user (schemas.User): The user data to be created.
        current_user (Annotated[schemas.User, Depends]): The currently authenticated user,
            obtained from the JWT token, who is attempting to create a new user.
        db (Session, optional): The database session used to interact with the database.
            Defaults to a session generated by `get_db`.

    Returns:
        schemas.User: The newly created active user.

    Raises:
        HTTPException: If the current user is not an admin.
    """
    if current_user.kind != 'admin':
        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED,
                             detail='You are not an admin user')

    user_db = create_user(db, user)
    return schemas.User(dni=user_db.dni, username=user_db.username, kind=user_db.kind, password=user_db.password)


@app.put("/users/{username}/", response_model=schemas.User)
def update(username: str, user: schemas.User, current_user: Annotated[schemas.User, Depends(get_current_user)],
           db: Session = Depends(get_db)) -> schemas.User:
    """
    Updates the details of a specific user by username if the current user is an admin.

    Args:
        username (str): The username of the user to be updated.
        user (schemas.User): The updated user data.
        current_user (Annotated[schemas.User, Depends]): The currently authenticated user,
            obtained from the JWT token, who is attempting to update the user details.
        db (Session, optional): The database session used to query and update the database.
            Defaults to a session generated by `get_db`.

    Returns:
        schemas.User: The updated user details.

    Raises:
        HTTPException: If the current user is not an admin.
    """
    if current_user.kind != 'admin':
        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED,
                             detail='You are not an admin user')

    user_db = update_user(db, username, user)
    return schemas.User(dni=user_db.dni, username=user_db.username, kind=user_db.kind, password=user_db.password)


@app.delete("/users/{username}", response_model=schemas.User)
def delete(username: str, current_user: Annotated[schemas.User, Depends(get_current_user)],
           db: Session = Depends(get_db)) -> schemas.User:
    """
    Deletes a specific user by username if the current user is an admin.

    Args:
        username (str): The username of the user to be deleted.
        current_user (Annotated[schemas.User, Depends]): The currently authenticated user,
            obtained from the JWT token, who is attempting to delete the user.
        db (Session, optional): The database session used to query and delete the user.
            Defaults to a session generated by `get_db`.

    Returns:
        schemas.User: The details of the deleted user.

    Raises:
        HTTPException: If the current user is not an admin.
    """
    if current_user.kind != 'admin':
        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED,
                             detail='You are not an admin user')
    
    user_db = delete_user(db, username)
    return schemas.User(dni=user_db.dni, username=user_db.username, kind=user_db.kind, password=user_db.password)


if __name__ == '__main__':
    uvicorn.run('app:app', reload=True)
